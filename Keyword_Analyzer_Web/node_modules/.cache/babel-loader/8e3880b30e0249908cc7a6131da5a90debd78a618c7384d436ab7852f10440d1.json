{"ast":null,"code":"// OpenAI API configuration\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || \"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\";\nexport class SimilarKeywordFinder {\n  /**\n   * GPT API kullanarak benzer keyword'leri bul\n   */\n  static async findSimilarKeywords(searchTerm, availableKeywords, maxResults = 1000) {\n    try {\n      const systemPrompt = `\nYou are an expert in keyword analysis, semantic similarity, and typo detection. Your task is to analyze a search term and find similar keywords from a provided list.\n\nYour analysis should include:\n1. **Semantic Similarity**: Keywords with similar meaning or concept\n2. **Typo Detection**: Keywords that might be typos or misspellings of the search term\n3. **Variations**: Different forms, abbreviations, or alternative spellings\n4. **Related Concepts**: Keywords that are contextually related\n5. **Partial Matches**: Keywords that contain parts of the search term\n\nAnalysis Rules:\n- Focus on finding ALL possible matches within the provided keyword list\n- Consider typos, misspellings, and common variations\n- Look for semantic similarities and related concepts\n- Return only keywords that exist in the provided list\n- Return maximum ${maxResults} keywords\n- Return results as a JSON array of strings\n\nExamples:\nSearch term: \"weather\"\nPossible matches: \"weather\", \"weater\", \"wether\", \"weather app\", \"weather forecast\", \"climate\", \"temperature\"\n\nSearch term: \"photo\"\nPossible matches: \"photo\", \"foto\", \"photography\", \"photo editor\", \"photo filter\", \"image\", \"picture\"\n`;\n      const userPrompt = `\nSearch term: \"${searchTerm}\"\n\nAvailable keywords to search within:\n${availableKeywords.join(', ')}\n\nPlease analyze the search term and find ALL similar keywords from the above list, including:\n- Exact matches\n- Typos and misspellings\n- Semantic similarities\n- Related concepts\n- Partial matches\n\nReturn the most relevant keywords as a JSON array, ordered by relevance:\n`;\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${OPENAI_API_KEY}`\n        },\n        body: JSON.stringify({\n          model: 'gpt-4o-mini',\n          messages: [{\n            role: 'system',\n            content: systemPrompt\n          }, {\n            role: 'user',\n            content: userPrompt\n          }],\n          temperature: 0.3,\n          max_tokens: 500\n        })\n      });\n\n      // Check if response is successful\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('OpenAI API error:', response.status, errorText);\n        throw new Error(`OpenAI API hatası: ${response.status}. Lütfen tekrar deneyin.`);\n      }\n      const result = await response.json();\n\n      // Check if response is valid\n      if (!result.choices || !result.choices[0] || !result.choices[0].message || !result.choices[0].message.content) {\n        console.error('Invalid OpenAI response:', result);\n        throw new Error('OpenAI API yanıtı geçersiz. Lütfen tekrar deneyin.');\n      }\n      const answer = result.choices[0].message.content.trim();\n      let similarKeywords = [];\n      try {\n        // Extract JSON from response\n        const jsonMatch = answer.match(/\\[.*\\]/);\n        if (jsonMatch) {\n          similarKeywords = JSON.parse(jsonMatch[0]);\n        } else {\n          // Fallback: try to parse the entire response\n          similarKeywords = JSON.parse(answer);\n        }\n\n        // Validate that all returned keywords exist in the original list\n        similarKeywords = similarKeywords.filter(keyword => availableKeywords.includes(keyword));\n\n        // Limit to maxResults\n        similarKeywords = similarKeywords.slice(0, maxResults);\n      } catch (parseError) {\n        console.error('Error parsing similar keywords response:', parseError);\n        // Fallback: use simple string matching\n        similarKeywords = this.fallbackSimilarKeywords(searchTerm, availableKeywords, maxResults);\n      }\n      return similarKeywords;\n    } catch (error) {\n      console.error('Error finding similar keywords:', error);\n      // Fallback to simple matching if API fails\n      return this.fallbackSimilarKeywords(searchTerm, availableKeywords, maxResults);\n    }\n  }\n\n  /**\n   * Fallback method for finding similar keywords using simple string matching\n   */\n  static fallbackSimilarKeywords(searchTerm, availableKeywords, maxResults) {\n    const searchWords = searchTerm.toLowerCase().split(/\\s+/);\n    const scoredKeywords = availableKeywords.map(keyword => {\n      const keywordWords = keyword.toLowerCase().split(/\\s+/);\n      let score = 0;\n\n      // Exact match gets highest score\n      if (keyword.toLowerCase().includes(searchTerm.toLowerCase())) {\n        score += 10;\n      }\n\n      // Word overlap scoring\n      searchWords.forEach(searchWord => {\n        keywordWords.forEach(keywordWord => {\n          if (keywordWord.includes(searchWord) || searchWord.includes(keywordWord)) {\n            score += 2;\n          }\n          if (keywordWord === searchWord) {\n            score += 5;\n          }\n        });\n      });\n      return {\n        keyword,\n        score\n      };\n    });\n    return scoredKeywords.filter(item => item.score > 0).sort((a, b) => b.score - a.score).slice(0, maxResults).map(item => item.keyword);\n  }\n\n  /**\n   * Mevcut keyword'lerden benzer olanları filtrele\n   */\n  static filterBySimilarKeywords(data, similarKeywords) {\n    if (similarKeywords.length === 0) return data;\n    return data.filter(item => {\n      const keyword = String(item.Keyword || '').toLowerCase();\n      return similarKeywords.some(similarKeyword => keyword.includes(similarKeyword.toLowerCase()) || similarKeyword.toLowerCase().includes(keyword));\n    });\n  }\n}","map":{"version":3,"names":["OPENAI_API_KEY","process","env","REACT_APP_OPENAI_API_KEY","SimilarKeywordFinder","findSimilarKeywords","searchTerm","availableKeywords","maxResults","systemPrompt","userPrompt","join","response","fetch","method","headers","body","JSON","stringify","model","messages","role","content","temperature","max_tokens","ok","errorText","text","console","error","status","Error","result","json","choices","message","answer","trim","similarKeywords","jsonMatch","match","parse","filter","keyword","includes","slice","parseError","fallbackSimilarKeywords","searchWords","toLowerCase","split","scoredKeywords","map","keywordWords","score","forEach","searchWord","keywordWord","item","sort","a","b","filterBySimilarKeywords","data","length","String","Keyword","some","similarKeyword"],"sources":["/Users/aibatyr/Documents/GitHub/KeyWords_Analyzer_Web/Keyword_Analyzer_Web/src/utils/similarKeywordFinder.ts"],"sourcesContent":["import { KeywordData } from '../types';\n\n// OpenAI API configuration\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || \"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\";\n\nexport class SimilarKeywordFinder {\n  \n  /**\n   * GPT API kullanarak benzer keyword'leri bul\n   */\n  static async findSimilarKeywords(\n    searchTerm: string, \n    availableKeywords: string[], \n    maxResults: number = 1000\n  ): Promise<string[]> {\n    try {\n      const systemPrompt = `\nYou are an expert in keyword analysis, semantic similarity, and typo detection. Your task is to analyze a search term and find similar keywords from a provided list.\n\nYour analysis should include:\n1. **Semantic Similarity**: Keywords with similar meaning or concept\n2. **Typo Detection**: Keywords that might be typos or misspellings of the search term\n3. **Variations**: Different forms, abbreviations, or alternative spellings\n4. **Related Concepts**: Keywords that are contextually related\n5. **Partial Matches**: Keywords that contain parts of the search term\n\nAnalysis Rules:\n- Focus on finding ALL possible matches within the provided keyword list\n- Consider typos, misspellings, and common variations\n- Look for semantic similarities and related concepts\n- Return only keywords that exist in the provided list\n- Return maximum ${maxResults} keywords\n- Return results as a JSON array of strings\n\nExamples:\nSearch term: \"weather\"\nPossible matches: \"weather\", \"weater\", \"wether\", \"weather app\", \"weather forecast\", \"climate\", \"temperature\"\n\nSearch term: \"photo\"\nPossible matches: \"photo\", \"foto\", \"photography\", \"photo editor\", \"photo filter\", \"image\", \"picture\"\n`;\n\n      const userPrompt = `\nSearch term: \"${searchTerm}\"\n\nAvailable keywords to search within:\n${availableKeywords.join(', ')}\n\nPlease analyze the search term and find ALL similar keywords from the above list, including:\n- Exact matches\n- Typos and misspellings\n- Semantic similarities\n- Related concepts\n- Partial matches\n\nReturn the most relevant keywords as a JSON array, ordered by relevance:\n`;\n\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${OPENAI_API_KEY}`\n        },\n        body: JSON.stringify({\n          model: 'gpt-4o-mini',\n          messages: [\n            { role: 'system', content: systemPrompt },\n            { role: 'user', content: userPrompt }\n          ],\n          temperature: 0.3,\n          max_tokens: 500\n        })\n      });\n\n      // Check if response is successful\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('OpenAI API error:', response.status, errorText);\n        throw new Error(`OpenAI API hatası: ${response.status}. Lütfen tekrar deneyin.`);\n      }\n\n      const result = await response.json();\n      \n      // Check if response is valid\n      if (!result.choices || !result.choices[0] || !result.choices[0].message || !result.choices[0].message.content) {\n        console.error('Invalid OpenAI response:', result);\n        throw new Error('OpenAI API yanıtı geçersiz. Lütfen tekrar deneyin.');\n      }\n      \n      const answer = result.choices[0].message.content.trim();\n      \n      let similarKeywords: string[] = [];\n      try {\n        // Extract JSON from response\n        const jsonMatch = answer.match(/\\[.*\\]/);\n        if (jsonMatch) {\n          similarKeywords = JSON.parse(jsonMatch[0]);\n        } else {\n          // Fallback: try to parse the entire response\n          similarKeywords = JSON.parse(answer);\n        }\n        \n        // Validate that all returned keywords exist in the original list\n        similarKeywords = similarKeywords.filter(keyword => \n          availableKeywords.includes(keyword)\n        );\n        \n        // Limit to maxResults\n        similarKeywords = similarKeywords.slice(0, maxResults);\n        \n      } catch (parseError) {\n        console.error('Error parsing similar keywords response:', parseError);\n        // Fallback: use simple string matching\n        similarKeywords = this.fallbackSimilarKeywords(searchTerm, availableKeywords, maxResults);\n      }\n\n      return similarKeywords;\n\n    } catch (error) {\n      console.error('Error finding similar keywords:', error);\n      // Fallback to simple matching if API fails\n      return this.fallbackSimilarKeywords(searchTerm, availableKeywords, maxResults);\n    }\n  }\n\n  /**\n   * Fallback method for finding similar keywords using simple string matching\n   */\n  private static fallbackSimilarKeywords(\n    searchTerm: string, \n    availableKeywords: string[], \n    maxResults: number\n  ): string[] {\n    const searchWords = searchTerm.toLowerCase().split(/\\s+/);\n    \n    const scoredKeywords = availableKeywords.map(keyword => {\n      const keywordWords = keyword.toLowerCase().split(/\\s+/);\n      let score = 0;\n      \n      // Exact match gets highest score\n      if (keyword.toLowerCase().includes(searchTerm.toLowerCase())) {\n        score += 10;\n      }\n      \n      // Word overlap scoring\n      searchWords.forEach(searchWord => {\n        keywordWords.forEach(keywordWord => {\n          if (keywordWord.includes(searchWord) || searchWord.includes(keywordWord)) {\n            score += 2;\n          }\n          if (keywordWord === searchWord) {\n            score += 5;\n          }\n        });\n      });\n      \n      return { keyword, score };\n    });\n    \n    return scoredKeywords\n      .filter(item => item.score > 0)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, maxResults)\n      .map(item => item.keyword);\n  }\n\n  /**\n   * Mevcut keyword'lerden benzer olanları filtrele\n   */\n  static filterBySimilarKeywords(\n    data: KeywordData[], \n    similarKeywords: string[]\n  ): KeywordData[] {\n    if (similarKeywords.length === 0) return data;\n    \n    return data.filter(item => {\n      const keyword = String(item.Keyword || '').toLowerCase();\n      return similarKeywords.some(similarKeyword => \n        keyword.includes(similarKeyword.toLowerCase()) ||\n        similarKeyword.toLowerCase().includes(keyword)\n      );\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}