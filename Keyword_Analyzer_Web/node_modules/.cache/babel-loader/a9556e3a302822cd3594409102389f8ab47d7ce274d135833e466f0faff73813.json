{"ast":null,"code":"import * as XLSX from 'xlsx';\nimport { saveAs } from 'file-saver';\nexport class ExportUtils {\n  /**\n   * Excel dosyası oluştur ve indir\n   */\n  static exportToExcel(data, filename, sheetName = 'ASO Data') {\n    try {\n      // Veriyi hazırla - sayısal değerleri doğru formatta tut\n      const processedData = data.map(row => {\n        const processedRow = {};\n        Object.entries(row).forEach(([key, value]) => {\n          // Sayısal sütunlar için özel işlem\n          if (this.isNumericColumn(key)) {\n            processedRow[key] = this.ensureNumericValue(value);\n          } else {\n            processedRow[key] = value;\n          }\n        });\n        return processedRow;\n      });\n\n      // Worksheet oluştur\n      const ws = XLSX.utils.json_to_sheet(processedData);\n\n      // Sayısal sütunlar için format ayarları\n      this.applyNumericFormats(ws, processedData);\n\n      // Workbook oluştur\n      const wb = XLSX.utils.book_new();\n      XLSX.utils.book_append_sheet(wb, ws, sheetName);\n\n      // Excel dosyasını buffer olarak oluştur\n      const excelBuffer = XLSX.write(wb, {\n        bookType: 'xlsx',\n        type: 'array',\n        cellStyles: true\n      });\n      const blob = new Blob([excelBuffer], {\n        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n      });\n\n      // Dosyayı indir\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n      const fullFilename = `${filename}_${timestamp}.xlsx`;\n      saveAs(blob, fullFilename);\n    } catch (error) {\n      console.error('Excel export error:', error);\n      throw new Error('Excel dosyası oluşturulamadı');\n    }\n  }\n\n  /**\n   * Sayısal sütun olup olmadığını kontrol et\n   */\n  static isNumericColumn(columnName) {\n    const numericColumns = ['Volume', 'Difficulty', 'Growth (Max Reach)', 'Max. Reach', 'No. of results', 'Title_Length', 'Subtitle_Length', 'Keywords_Length', 'Total_Volume', 'Total_Difficulty', 'Average_Volume', 'Average_Difficulty', 'Matched_Keywords_Count'];\n    return numericColumns.includes(columnName);\n  }\n\n  /**\n   * Değeri sayısal formatta tut\n   */\n  static ensureNumericValue(value) {\n    if (value === null || value === undefined || value === '') {\n      return 0;\n    }\n    try {\n      if (typeof value === 'number') {\n        return isNaN(value) ? 0 : value;\n      }\n\n      // String ise temizle ve parse et\n      if (typeof value === 'string') {\n        const cleaned = value.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n        if (cleaned === '' || cleaned === '-') {\n          return 0;\n        }\n        const parsed = parseFloat(cleaned);\n        return isNaN(parsed) ? 0 : parsed;\n      }\n\n      // Diğer tipler için string'e çevir ve parse et\n      const stringValue = String(value);\n      const cleaned = stringValue.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n      const parsed = parseFloat(cleaned);\n      return isNaN(parsed) ? 0 : parsed;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Sayısal sütunlar için format ayarları uygula\n   */\n  static applyNumericFormats(ws, data) {\n    if (data.length === 0) return;\n    const headers = Object.keys(data[0]);\n    const numericColumns = {};\n\n    // Sayısal sütunların indekslerini bul\n    headers.forEach((header, index) => {\n      if (this.isNumericColumn(header)) {\n        numericColumns[header] = index;\n      }\n    });\n\n    // Her sayısal sütun için format ayarla\n    Object.entries(numericColumns).forEach(([columnName, colIndex]) => {\n      const colLetter = XLSX.utils.encode_col(colIndex);\n\n      // Sütun genişliği ayarla\n      if (!ws['!cols']) ws['!cols'] = [];\n      ws['!cols'][colIndex] = {\n        width: 12\n      };\n\n      // Her hücre için sayısal format uygula\n      data.forEach((row, rowIndex) => {\n        const cellAddress = `${colLetter}${rowIndex + 2}`; // +2 çünkü header var ve Excel 1'den başlar\n        const cellValue = row[columnName];\n        if (ws[cellAddress]) {\n          // Hücre zaten varsa formatını güncelle\n          ws[cellAddress].t = 'n'; // number type\n          ws[cellAddress].z = '#,##0'; // number format\n        } else {\n          // Yeni hücre oluştur\n          ws[cellAddress] = {\n            v: this.ensureNumericValue(cellValue),\n            t: 'n',\n            z: '#,##0'\n          };\n        }\n      });\n    });\n  }\n\n  /**\n   * CSV dosyası oluştur ve indir\n   */\n  static exportToCsv(data, filename) {\n    try {\n      if (data.length === 0) {\n        throw new Error('Dışa aktarılacak veri yok');\n      }\n\n      // CSV başlıklarını oluştur\n      const headers = Object.keys(data[0]);\n      const csvContent = [headers.join(','), ...data.map(row => headers.map(header => {\n        const value = row[header];\n        // Sayısal değerleri doğru formatta tut\n        if (this.isNumericColumn(header)) {\n          const numericValue = this.ensureNumericValue(value);\n          return numericValue.toString();\n        }\n        // Virgül içeren değerleri tırnak içine al\n        const stringValue = String(value || '');\n        if (stringValue.includes(',')) {\n          return `\"${stringValue}\"`;\n        }\n        return stringValue;\n      }).join(','))].join('\\n');\n\n      // Blob oluştur\n      const blob = new Blob([csvContent], {\n        type: 'text/csv;charset=utf-8;'\n      });\n\n      // Dosyayı indir\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n      const fullFilename = `${filename}_${timestamp}.csv`;\n      saveAs(blob, fullFilename);\n    } catch (error) {\n      console.error('CSV export error:', error);\n      throw new Error('CSV dosyası oluşturulamadı');\n    }\n  }\n\n  /**\n   * Dosya adını güvenli hale getir\n   */\n  static sanitizeFilename(filename) {\n    return filename.replace(/[<>:\"/\\\\|?*]/g, '_').replace(/\\s+/g, '_').toLowerCase();\n  }\n\n  /**\n   * Timestamp oluştur\n   */\n  static generateTimestamp() {\n    return new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n  }\n}","map":{"version":3,"names":["XLSX","saveAs","ExportUtils","exportToExcel","data","filename","sheetName","processedData","map","row","processedRow","Object","entries","forEach","key","value","isNumericColumn","ensureNumericValue","ws","utils","json_to_sheet","applyNumericFormats","wb","book_new","book_append_sheet","excelBuffer","write","bookType","type","cellStyles","blob","Blob","timestamp","Date","toISOString","replace","slice","fullFilename","error","console","Error","columnName","numericColumns","includes","undefined","isNaN","cleaned","trim","parsed","parseFloat","stringValue","String","length","headers","keys","header","index","colIndex","colLetter","encode_col","width","rowIndex","cellAddress","cellValue","t","z","v","exportToCsv","csvContent","join","numericValue","toString","sanitizeFilename","toLowerCase","generateTimestamp"],"sources":["/Users/aibatyr/Documents/GitHub/KeyWords_Analyzer_Web/Keyword_Analyzer_Web/src/utils/exportUtils.ts"],"sourcesContent":["import * as XLSX from 'xlsx';\nimport { saveAs } from 'file-saver';\nimport { KeywordData, TitleSubtitleData } from '../types';\n\nexport class ExportUtils {\n  /**\n   * Excel dosyası oluştur ve indir\n   */\n  static exportToExcel(\n    data: KeywordData[] | TitleSubtitleData[],\n    filename: string,\n    sheetName: string = 'ASO Data'\n  ): void {\n    try {\n      // Veriyi hazırla - sayısal değerleri doğru formatta tut\n      const processedData = data.map(row => {\n        const processedRow: any = {};\n        \n        Object.entries(row).forEach(([key, value]) => {\n          // Sayısal sütunlar için özel işlem\n          if (this.isNumericColumn(key)) {\n            processedRow[key] = this.ensureNumericValue(value);\n          } else {\n            processedRow[key] = value;\n          }\n        });\n        \n        return processedRow;\n      });\n      \n      // Worksheet oluştur\n      const ws = XLSX.utils.json_to_sheet(processedData);\n      \n      // Sayısal sütunlar için format ayarları\n      this.applyNumericFormats(ws, processedData);\n      \n      // Workbook oluştur\n      const wb = XLSX.utils.book_new();\n      XLSX.utils.book_append_sheet(wb, ws, sheetName);\n      \n      // Excel dosyasını buffer olarak oluştur\n      const excelBuffer = XLSX.write(wb, { \n        bookType: 'xlsx', \n        type: 'array',\n        cellStyles: true\n      });\n      const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });\n      \n      // Dosyayı indir\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n      const fullFilename = `${filename}_${timestamp}.xlsx`;\n      saveAs(blob, fullFilename);\n      \n    } catch (error) {\n      console.error('Excel export error:', error);\n      throw new Error('Excel dosyası oluşturulamadı');\n    }\n  }\n  \n  /**\n   * Sayısal sütun olup olmadığını kontrol et\n   */\n  private static isNumericColumn(columnName: string): boolean {\n    const numericColumns = [\n      'Volume', \n      'Difficulty', \n      'Growth (Max Reach)', \n      'Max. Reach', \n      'No. of results',\n      'Title_Length',\n      'Subtitle_Length', \n      'Keywords_Length',\n      'Total_Volume',\n      'Total_Difficulty',\n      'Average_Volume',\n      'Average_Difficulty',\n      'Matched_Keywords_Count'\n    ];\n    return numericColumns.includes(columnName);\n  }\n  \n  /**\n   * Değeri sayısal formatta tut\n   */\n  private static ensureNumericValue(value: any): number {\n    if (value === null || value === undefined || value === '') {\n      return 0;\n    }\n    \n    try {\n      if (typeof value === 'number') {\n        return isNaN(value) ? 0 : value;\n      }\n      \n      // String ise temizle ve parse et\n      if (typeof value === 'string') {\n        const cleaned = value.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n        if (cleaned === '' || cleaned === '-') {\n          return 0;\n        }\n        const parsed = parseFloat(cleaned);\n        return isNaN(parsed) ? 0 : parsed;\n      }\n      \n      // Diğer tipler için string'e çevir ve parse et\n      const stringValue = String(value);\n      const cleaned = stringValue.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n      const parsed = parseFloat(cleaned);\n      return isNaN(parsed) ? 0 : parsed;\n    } catch {\n      return 0;\n    }\n  }\n  \n  /**\n   * Sayısal sütunlar için format ayarları uygula\n   */\n  private static applyNumericFormats(ws: XLSX.WorkSheet, data: any[]): void {\n    if (data.length === 0) return;\n    \n    const headers = Object.keys(data[0]);\n    const numericColumns: { [key: string]: number } = {};\n    \n    // Sayısal sütunların indekslerini bul\n    headers.forEach((header, index) => {\n      if (this.isNumericColumn(header)) {\n        numericColumns[header] = index;\n      }\n    });\n    \n    // Her sayısal sütun için format ayarla\n    Object.entries(numericColumns).forEach(([columnName, colIndex]) => {\n      const colLetter = XLSX.utils.encode_col(colIndex);\n      \n      // Sütun genişliği ayarla\n      if (!ws['!cols']) ws['!cols'] = [];\n      ws['!cols'][colIndex] = { width: 12 };\n      \n      // Her hücre için sayısal format uygula\n      data.forEach((row, rowIndex) => {\n        const cellAddress = `${colLetter}${rowIndex + 2}`; // +2 çünkü header var ve Excel 1'den başlar\n        const cellValue = row[columnName];\n        \n        if (ws[cellAddress]) {\n          // Hücre zaten varsa formatını güncelle\n          ws[cellAddress].t = 'n'; // number type\n          ws[cellAddress].z = '#,##0'; // number format\n        } else {\n          // Yeni hücre oluştur\n          ws[cellAddress] = {\n            v: this.ensureNumericValue(cellValue),\n            t: 'n',\n            z: '#,##0'\n          };\n        }\n      });\n    });\n  }\n  \n  /**\n   * CSV dosyası oluştur ve indir\n   */\n  static exportToCsv(\n    data: KeywordData[] | TitleSubtitleData[],\n    filename: string\n  ): void {\n    try {\n      if (data.length === 0) {\n        throw new Error('Dışa aktarılacak veri yok');\n      }\n      \n      // CSV başlıklarını oluştur\n      const headers = Object.keys(data[0]);\n      const csvContent = [\n        headers.join(','),\n        ...data.map(row => \n          headers.map(header => {\n            const value = row[header as keyof typeof row];\n            // Sayısal değerleri doğru formatta tut\n            if (this.isNumericColumn(header)) {\n              const numericValue = this.ensureNumericValue(value);\n              return numericValue.toString();\n            }\n            // Virgül içeren değerleri tırnak içine al\n            const stringValue = String(value || '');\n            if (stringValue.includes(',')) {\n              return `\"${stringValue}\"`;\n            }\n            return stringValue;\n          }).join(',')\n        )\n      ].join('\\n');\n      \n      // Blob oluştur\n      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n      \n      // Dosyayı indir\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n      const fullFilename = `${filename}_${timestamp}.csv`;\n      saveAs(blob, fullFilename);\n      \n    } catch (error) {\n      console.error('CSV export error:', error);\n      throw new Error('CSV dosyası oluşturulamadı');\n    }\n  }\n  \n  /**\n   * Dosya adını güvenli hale getir\n   */\n  static sanitizeFilename(filename: string): string {\n    return filename\n      .replace(/[<>:\"/\\\\|?*]/g, '_')\n      .replace(/\\s+/g, '_')\n      .toLowerCase();\n  }\n  \n  /**\n   * Timestamp oluştur\n   */\n  static generateTimestamp(): string {\n    return new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}