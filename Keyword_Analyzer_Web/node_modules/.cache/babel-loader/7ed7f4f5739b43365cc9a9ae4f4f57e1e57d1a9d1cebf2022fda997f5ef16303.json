{"ast":null,"code":"import Papa from 'papaparse';\nexport class CsvProcessor {\n  /**\n   * CSV dosyasından sütun bilgilerini analiz et\n   */\n  static analyzeColumns(data) {\n    if (data.length === 0) return [];\n    const columns = Object.keys(data[0]);\n    const columnInfo = [];\n    columns.forEach(columnName => {\n      const values = data.map(row => row[columnName]);\n      const nonNullValues = values.filter(val => val !== null && val !== undefined && val !== '');\n\n      // Veri tipini belirle\n      const type = this.determineColumnType(values);\n\n      // Boolean değerleri kontrol et\n      const booleanValues = type === 'boolean' ? Array.from(new Set(values.filter(val => val === true || val === false))) : undefined;\n\n      // Sayısal değerler için min/max hesapla\n      let min;\n      let max;\n      if (type === 'number' || type === 'percentage') {\n        const numericValues = nonNullValues.map(val => this.convertToNumber(val));\n        const validNumericValues = numericValues.filter(val => !isNaN(val) && isFinite(val));\n        if (validNumericValues.length > 0) {\n          min = Math.min(...validNumericValues);\n          max = Math.max(...validNumericValues);\n        }\n      }\n\n      // Benzersiz değerleri al (string sütunlar için)\n      const uniqueValues = type === 'string' ? Array.from(new Set(nonNullValues)) : undefined;\n      columnInfo.push({\n        name: columnName,\n        type,\n        min,\n        max,\n        hasNulls: values.length !== nonNullValues.length,\n        uniqueValues,\n        booleanValues\n      });\n    });\n    return columnInfo;\n  }\n\n  /**\n   * Sütun tipini belirle\n   */\n  static determineColumnType(values) {\n    const nonNullValues = values.filter(val => val !== null && val !== undefined && val !== '');\n    if (nonNullValues.length === 0) return 'string';\n\n    // Boolean kontrolü\n    const booleanCount = nonNullValues.filter(val => val === true || val === false || val === 'true' || val === 'false' || val === 'True' || val === 'False').length;\n    if (booleanCount === nonNullValues.length) return 'boolean';\n\n    // Yüzde kontrolü\n    const percentageCount = nonNullValues.filter(val => typeof val === 'string' && val.includes('%')).length;\n    if (percentageCount > 0) return 'percentage';\n\n    // Sayı kontrolü\n    const numericCount = nonNullValues.filter(val => {\n      if (typeof val === 'number') return !isNaN(val);\n      if (typeof val === 'string') {\n        const cleaned = val.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n        return !isNaN(parseFloat(cleaned)) && cleaned !== '';\n      }\n      return false;\n    }).length;\n    if (numericCount === nonNullValues.length) return 'number';\n\n    // Tarih kontrolü (basit)\n    const dateCount = nonNullValues.filter(val => {\n      if (typeof val === 'string') {\n        // Basit tarih formatları kontrolü\n        const datePatterns = [/^\\d{4}-\\d{2}-\\d{2}$/,\n        // YYYY-MM-DD\n        /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n        // MM/DD/YYYY\n        /^\\d{2}-\\d{2}-\\d{4}$/ // MM-DD-YYYY\n        ];\n        return datePatterns.some(pattern => pattern.test(val));\n      }\n      return false;\n    }).length;\n    if (dateCount > nonNullValues.length * 0.8) return 'date';\n    return 'string';\n  }\n\n  /**\n   * Veriyi dinamik olarak işle\n   */\n  static processDataDynamically(data, columnInfo, nullHandling = 'zero') {\n    return data.map(row => {\n      const processedRow = {};\n      columnInfo.forEach(column => {\n        const value = row[column.name];\n        switch (column.type) {\n          case 'number':\n            processedRow[column.name] = this.convertToNumber(value);\n            break;\n          case 'percentage':\n            processedRow[column.name] = this.convertPercentageToNumber(value);\n            break;\n          case 'boolean':\n            processedRow[column.name] = this.convertToBoolean(value);\n            break;\n          case 'date':\n            processedRow[column.name] = this.convertToDate(value);\n            break;\n          default:\n            processedRow[column.name] = value;\n        }\n\n        // Null değerleri işle\n        if (processedRow[column.name] === null || processedRow[column.name] === undefined) {\n          switch (nullHandling) {\n            case 'zero':\n              processedRow[column.name] = column.type === 'string' ? '' : 0;\n              break;\n            case 'null':\n              processedRow[column.name] = null;\n              break;\n            case 'exclude':\n              // Bu satırı filtreleme sırasında çıkaracağız\n              break;\n          }\n        }\n      });\n      return processedRow;\n    });\n  }\n\n  /**\n   * Yüzde değerini sayıya çevir\n   */\n  static convertPercentageToNumber(value) {\n    if (value === null || value === undefined || value === '') {\n      return 0;\n    }\n    try {\n      if (typeof value === 'number') {\n        return isNaN(value) ? 0 : value;\n      }\n      if (typeof value === 'string') {\n        const cleaned = value.replace(/,/g, '').replace(/\\s/g, '').trim();\n        if (cleaned === '' || cleaned === '-') {\n          return 0;\n        }\n\n        // Yüzde işaretini kaldır ve parse et\n        const withoutPercent = cleaned.replace(/%/g, '');\n        const parsed = parseFloat(withoutPercent);\n        return isNaN(parsed) ? 0 : parsed;\n      }\n      return 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Boolean değere çevir\n   */\n  static convertToBoolean(value) {\n    if (value === null || value === undefined || value === '') {\n      return null;\n    }\n    if (typeof value === 'boolean') {\n      return value;\n    }\n    if (typeof value === 'string') {\n      const lower = value.toLowerCase().trim();\n      if (lower === 'true' || lower === '1' || lower === 'yes') {\n        return true;\n      }\n      if (lower === 'false' || lower === '0' || lower === 'no') {\n        return false;\n      }\n    }\n    if (typeof value === 'number') {\n      return value === 1;\n    }\n    return null;\n  }\n\n  /**\n   * Tarih değerine çevir\n   */\n  static convertToDate(value) {\n    if (value === null || value === undefined || value === '') {\n      return null;\n    }\n    if (typeof value === 'string') {\n      // Basit tarih formatı kontrolü\n      const datePatterns = [/^\\d{4}-\\d{2}-\\d{2}$/,\n      // YYYY-MM-DD\n      /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n      // MM/DD/YYYY\n      /^\\d{2}-\\d{2}-\\d{4}$/ // MM-DD-YYYY\n      ];\n      if (datePatterns.some(pattern => pattern.test(value))) {\n        return value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Tek klasördeki tüm CSV dosyalarını birleştirir\n   */\n  static async mergeNoDuplicateData(files) {\n    const allData = [];\n    let allColumnInfo = [];\n    for (const file of files) {\n      try {\n        const rawData = await this.parseCsvFile(file);\n\n        // İlk dosyadan sütun bilgilerini al\n        if (allColumnInfo.length === 0) {\n          allColumnInfo = this.analyzeColumns(rawData);\n        }\n\n        // Veriyi dinamik olarak işle\n        const processedData = this.processDataDynamically(rawData, allColumnInfo);\n\n        // Kategori bilgisini ekle\n        const dataWithCategory = processedData.map(row => ({\n          ...row,\n          Category: this.extractCategoryFromFileName(file.name)\n        }));\n        allData.push(...dataWithCategory);\n      } catch (error) {\n        console.error(`Error processing file ${file.name}:`, error);\n      }\n    }\n    return {\n      data: allData.sort((a, b) => (b.Difficulty || 0) - (a.Difficulty || 0)),\n      columnInfo: allColumnInfo\n    };\n  }\n\n  /**\n   * Tarih modu için çoklu klasör işleme\n   */\n  static async mergeWithDateData(folders) {\n    const allData = [];\n    let allColumnInfo = [];\n    for (const folder of folders) {\n      var _folder$, _folder$$webkitRelati;\n      const folderName = ((_folder$ = folder[0]) === null || _folder$ === void 0 ? void 0 : (_folder$$webkitRelati = _folder$.webkitRelativePath) === null || _folder$$webkitRelati === void 0 ? void 0 : _folder$$webkitRelati.split('/')[0]) || 'unknown';\n      const dateInfo = folderName.split('_')[0];\n      for (const file of folder) {\n        try {\n          const rawData = await this.parseCsvFile(file);\n\n          // İlk dosyadan sütun bilgilerini al\n          if (allColumnInfo.length === 0) {\n            allColumnInfo = this.analyzeColumns(rawData);\n          }\n\n          // Veriyi dinamik olarak işle\n          const processedData = this.processDataDynamically(rawData, allColumnInfo);\n          const dataWithCategory = processedData.map(row => ({\n            ...row,\n            Category: this.extractCategoryFromFileName(file.name),\n            Date: dateInfo\n          }));\n          allData.push(...dataWithCategory);\n        } catch (error) {\n          console.error(`Error processing file ${file.name}:`, error);\n        }\n      }\n    }\n    return {\n      data: allData.sort((a, b) => (b.Difficulty || 0) - (a.Difficulty || 0)),\n      columnInfo: allColumnInfo\n    };\n  }\n\n  /**\n   * Tek CSV dosyası işleme\n   */\n  static async processSingleCsvFile(file) {\n    try {\n      const rawData = await this.parseCsvFile(file);\n      const columnInfo = this.analyzeColumns(rawData);\n      const processedData = this.processDataDynamically(rawData, columnInfo);\n      const dataWithCategory = processedData.map(row => ({\n        ...row,\n        Category: this.extractCategoryFromFileName(file.name)\n      }));\n      return {\n        data: dataWithCategory.sort((a, b) => (b.Difficulty || 0) - (a.Difficulty || 0)),\n        columnInfo\n      };\n    } catch (error) {\n      console.error(`Error processing single file ${file.name}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * KVD (Keyword, Volume, Difficulty) filtresi\n   */\n  static filterKVD(data, limit) {\n    return data.filter(row => (row.Volume || 0) >= 20 && (row.Difficulty || 0) <= limit).sort((a, b) => (b.Volume || 0) - (a.Volume || 0));\n  }\n\n  /**\n   * Kelime frekans analizi\n   */\n  static getWordFrequency(data) {\n    const words = data.map(row => row.Keyword).join(' ').split(/\\s+/).filter(word => word.length > 0);\n    const frequencyMap = new Map();\n    words.forEach(word => {\n      const normalized = word.toLowerCase();\n      frequencyMap.set(normalized, (frequencyMap.get(normalized) || 0) + 1);\n    });\n    const result = Array.from(frequencyMap.entries()).map(([word, frequency]) => {\n      var _data$;\n      return {\n        word,\n        frequency,\n        category: ((_data$ = data[0]) === null || _data$ === void 0 ? void 0 : _data$.Category) || 'Frequency'\n      };\n    }).sort((a, b) => b.frequency - a.frequency);\n    return result;\n  }\n\n  /**\n   * Branded kelimeleri filtrele\n   */\n  static filterBrandedWords(frequencyData) {\n    const stopWords = ['free', 'new', 'best', 'top', 'iphone', 'ipad', 'android', 'google', 'store', 'download', 'downloads', 'for', 'apple', 'with', 'yours', 'a', 'about', 'above', 'after', 'again', 'against', 'all', 'am', 'an', 'and', 'any', 'app', 'are', 'aren\\'t', 'as', 'at', 'be', 'because', 'been', 'before', 'being', 'below', 'between', 'both', 'but', 'by', 'can\\'t', 'cannot', 'could', 'couldn\\'t', 'did', 'didn\\'t', 'do', 'does', 'doesn\\'t', 'doing', 'don\\'t', 'down', 'during', 'each', 'few', 'from', 'further', 'had', 'hadn\\'t', 'has', 'hasn\\'t', 'have', 'haven\\'t', 'having', 'he', 'he\\'d', 'he\\'ll', 'he\\'s', 'her', 'here', 'here\\'s', 'hers', 'herself', 'him', 'himself', 'his', 'how', 'how\\'s', 'i', 'i\\'d', 'i\\'ll', 'i\\'m', 'i\\'ve', 'if', 'in', 'into', 'is', 'isn\\'t', 'it', 'it\\'s', 'its', 'itself', 'let\\'s', 'me', 'more', 'most', 'mustn\\'t', 'my', 'myself', 'no', 'nor', 'not', 'of', 'off', 'on', 'once', 'only', 'or', 'other', 'ought', 'our', 'ours', 'ourselves', 'out', 'over', 'own', 'same', 'shan\\'t', 'she', 'she\\'d', 'she\\'ll', 'she\\'s', 'should', 'shouldn\\'t', 'so', 'some', 'such', 'than', 'that', 'that\\'s', 'the', 'their', 'theirs', 'them', 'themselves', 'then', 'there', 'there\\'s', 'these', 'they', 'they\\'d', 'they\\'ll', 'they\\'re', 'they\\'ve', 'this', 'those', 'through', 'to', 'too', 'under', 'until', 'up', 'very', 'was', 'wasn\\'t', 'we', 'we\\'d', 'we\\'ll', 'we\\'re', 'we\\'ve', 'were', 'weren\\'t', 'what', 'what\\'s', 'when', 'when\\'s', 'where', 'where\\'s', 'which', 'while', 'who', 'who\\'s', 'whom', 'why', 'why\\'s', 'won\\'t', 'would', 'wouldn\\'t', 'you', 'you\\'d', 'you\\'ll', 'you\\'re', 'you\\'ve', 'your', 'yours', 'yourself', 'yourselves'];\n    return frequencyData.filter(item => {\n      const word = item.word.toLowerCase();\n      return !stopWords.includes(word);\n    });\n  }\n\n  /**\n   * Çoğul eklerini kaldır\n   */\n  static removeSuffixes(frequencyData) {\n    return frequencyData.map(item => {\n      let word = item.word.toLowerCase();\n\n      // Basit çoğul ek kaldırma kuralları\n      if (word.endsWith('ies')) {\n        word = word.slice(0, -3) + 'y';\n      } else if (word.endsWith('es')) {\n        word = word.slice(0, -2);\n      } else if (word.endsWith('s')) {\n        word = word.slice(0, -1);\n      }\n      return {\n        ...item,\n        word\n      };\n    });\n  }\n\n  /**\n   * CSV dosyasını parse et\n   */\n  static async parseCsvFile(file) {\n    return new Promise((resolve, reject) => {\n      Papa.parse(file, {\n        header: true,\n        skipEmptyLines: true,\n        complete: results => {\n          if (results.errors.length > 0) {\n            reject(new Error(`CSV parsing errors: ${results.errors.map(e => e.message).join(', ')}`));\n          } else {\n            resolve(results.data);\n          }\n        },\n        error: error => {\n          reject(error);\n        }\n      });\n    });\n  }\n\n  /**\n   * Herhangi bir değeri güvenli şekilde number'a çevir\n   */\n  static convertToNumber(value) {\n    if (value === null || value === undefined || value === '') {\n      return 0;\n    }\n    try {\n      // String ise temizle\n      if (typeof value === 'string') {\n        const cleaned = value.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n        if (cleaned === '' || cleaned === '-') {\n          return 0;\n        }\n        const parsed = parseFloat(cleaned);\n        return isNaN(parsed) ? 0 : parsed;\n      }\n\n      // Number ise direkt döndür\n      if (typeof value === 'number') {\n        return isNaN(value) ? 0 : value;\n      }\n\n      // Diğer tipler için string'e çevir ve parse et\n      const stringValue = String(value);\n      const cleaned = stringValue.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n      const parsed = parseFloat(cleaned);\n      return isNaN(parsed) ? 0 : parsed;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Growth değerini integer'a çevir (geriye uyumluluk için)\n   */\n  static convertGrowthToInt(growth) {\n    return this.convertToNumber(growth);\n  }\n\n  /**\n   * Dosya adından kategori çıkar\n   */\n  static extractCategoryFromFileName(fileName) {\n    const nameWithoutExt = fileName.replace('.csv', '');\n    const parts = nameWithoutExt.split('-');\n    if (parts.length >= 4 && parts[0] === 'trending' && parts[1] === 'keywords') {\n      return parts.slice(3).join('-');\n    } else {\n      return parts[parts.length - 1] || nameWithoutExt;\n    }\n  }\n}","map":{"version":3,"names":["Papa","CsvProcessor","analyzeColumns","data","length","columns","Object","keys","columnInfo","forEach","columnName","values","map","row","nonNullValues","filter","val","undefined","type","determineColumnType","booleanValues","Array","from","Set","min","max","numericValues","convertToNumber","validNumericValues","isNaN","isFinite","Math","uniqueValues","push","name","hasNulls","booleanCount","percentageCount","includes","numericCount","cleaned","replace","trim","parseFloat","dateCount","datePatterns","some","pattern","test","processDataDynamically","nullHandling","processedRow","column","value","convertPercentageToNumber","convertToBoolean","convertToDate","withoutPercent","parsed","lower","toLowerCase","mergeNoDuplicateData","files","allData","allColumnInfo","file","rawData","parseCsvFile","processedData","dataWithCategory","Category","extractCategoryFromFileName","error","console","sort","a","b","Difficulty","mergeWithDateData","folders","folder","_folder$","_folder$$webkitRelati","folderName","webkitRelativePath","split","dateInfo","Date","processSingleCsvFile","filterKVD","limit","Volume","getWordFrequency","words","Keyword","join","word","frequencyMap","Map","normalized","set","get","result","entries","frequency","_data$","category","filterBrandedWords","frequencyData","stopWords","item","removeSuffixes","endsWith","slice","Promise","resolve","reject","parse","header","skipEmptyLines","complete","results","errors","Error","e","message","stringValue","String","convertGrowthToInt","growth","fileName","nameWithoutExt","parts"],"sources":["/Users/aibatyr/Documents/GitHub/KeyWords_Analyzer_Web/Keyword_Analyzer_Web/src/utils/csvProcessor.ts"],"sourcesContent":["import Papa from 'papaparse';\nimport { KeywordData, ColumnInfo } from '../types';\n\nexport class CsvProcessor {\n  /**\n   * CSV dosyasından sütun bilgilerini analiz et\n   */\n  static analyzeColumns(data: any[]): ColumnInfo[] {\n    if (data.length === 0) return [];\n\n    const columns = Object.keys(data[0]);\n    const columnInfo: ColumnInfo[] = [];\n\n    columns.forEach(columnName => {\n      const values = data.map(row => row[columnName]);\n      const nonNullValues = values.filter(val => val !== null && val !== undefined && val !== '');\n      \n      // Veri tipini belirle\n      const type = this.determineColumnType(values);\n      \n      // Boolean değerleri kontrol et\n      const booleanValues = type === 'boolean' ? \n        Array.from(new Set(values.filter(val => val === true || val === false))) as boolean[] : \n        undefined;\n\n      // Sayısal değerler için min/max hesapla\n      let min: number | undefined;\n      let max: number | undefined;\n      \n      if (type === 'number' || type === 'percentage') {\n        const numericValues = nonNullValues.map(val => this.convertToNumber(val));\n        const validNumericValues = numericValues.filter(val => !isNaN(val) && isFinite(val));\n        \n        if (validNumericValues.length > 0) {\n          min = Math.min(...validNumericValues);\n          max = Math.max(...validNumericValues);\n        }\n      }\n\n      // Benzersiz değerleri al (string sütunlar için)\n      const uniqueValues = type === 'string' ? \n        Array.from(new Set(nonNullValues)) : \n        undefined;\n\n      columnInfo.push({\n        name: columnName,\n        type,\n        min,\n        max,\n        hasNulls: values.length !== nonNullValues.length,\n        uniqueValues,\n        booleanValues\n      });\n    });\n\n    return columnInfo;\n  }\n\n  /**\n   * Sütun tipini belirle\n   */\n  private static determineColumnType(values: any[]): 'string' | 'number' | 'boolean' | 'percentage' | 'date' {\n    const nonNullValues = values.filter(val => val !== null && val !== undefined && val !== '');\n    \n    if (nonNullValues.length === 0) return 'string';\n\n    // Boolean kontrolü\n    const booleanCount = nonNullValues.filter(val => \n      val === true || val === false || \n      val === 'true' || val === 'false' ||\n      val === 'True' || val === 'False'\n    ).length;\n    \n    if (booleanCount === nonNullValues.length) return 'boolean';\n\n    // Yüzde kontrolü\n    const percentageCount = nonNullValues.filter(val => \n      typeof val === 'string' && val.includes('%')\n    ).length;\n    \n    if (percentageCount > 0) return 'percentage';\n\n    // Sayı kontrolü\n    const numericCount = nonNullValues.filter(val => {\n      if (typeof val === 'number') return !isNaN(val);\n      if (typeof val === 'string') {\n        const cleaned = val.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n        return !isNaN(parseFloat(cleaned)) && cleaned !== '';\n      }\n      return false;\n    }).length;\n\n    if (numericCount === nonNullValues.length) return 'number';\n\n    // Tarih kontrolü (basit)\n    const dateCount = nonNullValues.filter(val => {\n      if (typeof val === 'string') {\n        // Basit tarih formatları kontrolü\n        const datePatterns = [\n          /^\\d{4}-\\d{2}-\\d{2}$/, // YYYY-MM-DD\n          /^\\d{2}\\/\\d{2}\\/\\d{4}$/, // MM/DD/YYYY\n          /^\\d{2}-\\d{2}-\\d{4}$/, // MM-DD-YYYY\n        ];\n        return datePatterns.some(pattern => pattern.test(val));\n      }\n      return false;\n    }).length;\n\n    if (dateCount > nonNullValues.length * 0.8) return 'date';\n\n    return 'string';\n  }\n\n  /**\n   * Veriyi dinamik olarak işle\n   */\n  static processDataDynamically(data: any[], columnInfo: ColumnInfo[], nullHandling: 'zero' | 'null' | 'exclude' = 'zero'): any[] {\n    return data.map(row => {\n      const processedRow: any = {};\n\n      columnInfo.forEach(column => {\n        const value = row[column.name];\n        \n        switch (column.type) {\n          case 'number':\n            processedRow[column.name] = this.convertToNumber(value);\n            break;\n          case 'percentage':\n            processedRow[column.name] = this.convertPercentageToNumber(value);\n            break;\n          case 'boolean':\n            processedRow[column.name] = this.convertToBoolean(value);\n            break;\n          case 'date':\n            processedRow[column.name] = this.convertToDate(value);\n            break;\n          default:\n            processedRow[column.name] = value;\n        }\n\n        // Null değerleri işle\n        if (processedRow[column.name] === null || processedRow[column.name] === undefined) {\n          switch (nullHandling) {\n            case 'zero':\n              processedRow[column.name] = column.type === 'string' ? '' : 0;\n              break;\n            case 'null':\n              processedRow[column.name] = null;\n              break;\n            case 'exclude':\n              // Bu satırı filtreleme sırasında çıkaracağız\n              break;\n          }\n        }\n      });\n\n      return processedRow;\n    });\n  }\n\n  /**\n   * Yüzde değerini sayıya çevir\n   */\n  private static convertPercentageToNumber(value: any): number {\n    if (value === null || value === undefined || value === '') {\n      return 0;\n    }\n\n    try {\n      if (typeof value === 'number') {\n        return isNaN(value) ? 0 : value;\n      }\n\n      if (typeof value === 'string') {\n        const cleaned = value.replace(/,/g, '').replace(/\\s/g, '').trim();\n        if (cleaned === '' || cleaned === '-') {\n          return 0;\n        }\n        \n        // Yüzde işaretini kaldır ve parse et\n        const withoutPercent = cleaned.replace(/%/g, '');\n        const parsed = parseFloat(withoutPercent);\n        return isNaN(parsed) ? 0 : parsed;\n      }\n\n      return 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Boolean değere çevir\n   */\n  private static convertToBoolean(value: any): boolean | null {\n    if (value === null || value === undefined || value === '') {\n      return null;\n    }\n\n    if (typeof value === 'boolean') {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      const lower = value.toLowerCase().trim();\n      if (lower === 'true' || lower === '1' || lower === 'yes') {\n        return true;\n      }\n      if (lower === 'false' || lower === '0' || lower === 'no') {\n        return false;\n      }\n    }\n\n    if (typeof value === 'number') {\n      return value === 1;\n    }\n\n    return null;\n  }\n\n  /**\n   * Tarih değerine çevir\n   */\n  private static convertToDate(value: any): string | null {\n    if (value === null || value === undefined || value === '') {\n      return null;\n    }\n\n    if (typeof value === 'string') {\n      // Basit tarih formatı kontrolü\n      const datePatterns = [\n        /^\\d{4}-\\d{2}-\\d{2}$/, // YYYY-MM-DD\n        /^\\d{2}\\/\\d{2}\\/\\d{4}$/, // MM/DD/YYYY\n        /^\\d{2}-\\d{2}-\\d{4}$/, // MM-DD-YYYY\n      ];\n      \n      if (datePatterns.some(pattern => pattern.test(value))) {\n        return value;\n      }\n    }\n\n    return value;\n  }\n\n  /**\n   * Tek klasördeki tüm CSV dosyalarını birleştirir\n   */\n  static async mergeNoDuplicateData(files: File[]): Promise<{ data: KeywordData[], columnInfo: ColumnInfo[] }> {\n    const allData: KeywordData[] = [];\n    let allColumnInfo: ColumnInfo[] = [];\n    \n    for (const file of files) {\n      try {\n        const rawData = await this.parseCsvFile(file);\n        \n        // İlk dosyadan sütun bilgilerini al\n        if (allColumnInfo.length === 0) {\n          allColumnInfo = this.analyzeColumns(rawData);\n        }\n        \n        // Veriyi dinamik olarak işle\n        const processedData = this.processDataDynamically(rawData, allColumnInfo);\n        \n        // Kategori bilgisini ekle\n        const dataWithCategory = processedData.map(row => ({\n          ...row,\n          Category: this.extractCategoryFromFileName(file.name),\n        }));\n        \n        allData.push(...dataWithCategory);\n      } catch (error) {\n        console.error(`Error processing file ${file.name}:`, error);\n      }\n    }\n    \n    return {\n      data: allData.sort((a, b) => (b.Difficulty || 0) - (a.Difficulty || 0)),\n      columnInfo: allColumnInfo\n    };\n  }\n  \n  /**\n   * Tarih modu için çoklu klasör işleme\n   */\n  static async mergeWithDateData(folders: File[][]): Promise<{ data: KeywordData[], columnInfo: ColumnInfo[] }> {\n    const allData: KeywordData[] = [];\n    let allColumnInfo: ColumnInfo[] = [];\n    \n    for (const folder of folders) {\n      const folderName = folder[0]?.webkitRelativePath?.split('/')[0] || 'unknown';\n      const dateInfo = folderName.split('_')[0];\n      \n      for (const file of folder) {\n        try {\n          const rawData = await this.parseCsvFile(file);\n          \n          // İlk dosyadan sütun bilgilerini al\n          if (allColumnInfo.length === 0) {\n            allColumnInfo = this.analyzeColumns(rawData);\n          }\n          \n          // Veriyi dinamik olarak işle\n          const processedData = this.processDataDynamically(rawData, allColumnInfo);\n          \n          const dataWithCategory = processedData.map(row => ({\n            ...row,\n            Category: this.extractCategoryFromFileName(file.name),\n            Date: dateInfo,\n          }));\n          \n          allData.push(...dataWithCategory);\n        } catch (error) {\n          console.error(`Error processing file ${file.name}:`, error);\n        }\n      }\n    }\n    \n    return {\n      data: allData.sort((a, b) => (b.Difficulty || 0) - (a.Difficulty || 0)),\n      columnInfo: allColumnInfo\n    };\n  }\n  \n  /**\n   * Tek CSV dosyası işleme\n   */\n  static async processSingleCsvFile(file: File): Promise<{ data: KeywordData[], columnInfo: ColumnInfo[] }> {\n    try {\n      const rawData = await this.parseCsvFile(file);\n      const columnInfo = this.analyzeColumns(rawData);\n      const processedData = this.processDataDynamically(rawData, columnInfo);\n      \n      const dataWithCategory = processedData.map(row => ({\n        ...row,\n        Category: this.extractCategoryFromFileName(file.name),\n      }));\n      \n      return {\n        data: dataWithCategory.sort((a, b) => (b.Difficulty || 0) - (a.Difficulty || 0)),\n        columnInfo\n      };\n    } catch (error) {\n      console.error(`Error processing single file ${file.name}:`, error);\n      throw error;\n    }\n  }\n  \n  /**\n   * KVD (Keyword, Volume, Difficulty) filtresi\n   */\n  static filterKVD(data: KeywordData[], limit: number): KeywordData[] {\n    return data\n      .filter(row => (row.Volume || 0) >= 20 && (row.Difficulty || 0) <= limit)\n      .sort((a, b) => (b.Volume || 0) - (a.Volume || 0));\n  }\n  \n  /**\n   * Kelime frekans analizi\n   */\n  static getWordFrequency(data: KeywordData[]): { word: string; frequency: number; category?: string }[] {\n    const words = data\n      .map(row => row.Keyword)\n      .join(' ')\n      .split(/\\s+/)\n      .filter(word => word.length > 0);\n    \n    const frequencyMap = new Map<string, number>();\n    words.forEach(word => {\n      const normalized = word.toLowerCase();\n      frequencyMap.set(normalized, (frequencyMap.get(normalized) || 0) + 1);\n    });\n    \n    const result = Array.from(frequencyMap.entries())\n      .map(([word, frequency]) => ({\n        word,\n        frequency,\n        category: data[0]?.Category || 'Frequency',\n      }))\n      .sort((a, b) => b.frequency - a.frequency);\n    \n    return result;\n  }\n  \n  /**\n   * Branded kelimeleri filtrele\n   */\n  static filterBrandedWords(frequencyData: { word: string; frequency: number; category?: string }[]): { word: string; frequency: number; category?: string }[] {\n    const stopWords = [\n      'free', 'new', 'best', 'top', 'iphone', 'ipad', 'android', 'google', 'store',\n      'download', 'downloads', 'for', 'apple', 'with', 'yours', 'a', 'about', 'above', 'after', 'again', 'against', 'all',\n      'am', 'an', 'and', 'any', 'app', 'are', 'aren\\'t', 'as', 'at', 'be', 'because', 'been', 'before', 'being', 'below',\n      'between', 'both', 'but', 'by', 'can\\'t', 'cannot', 'could', 'couldn\\'t', 'did', 'didn\\'t', 'do', 'does', 'doesn\\'t',\n      'doing', 'don\\'t', 'down', 'during', 'each', 'few', 'from', 'further', 'had', 'hadn\\'t', 'has', 'hasn\\'t', 'have',\n      'haven\\'t', 'having', 'he', 'he\\'d', 'he\\'ll', 'he\\'s', 'her', 'here', 'here\\'s', 'hers', 'herself', 'him', 'himself',\n      'his', 'how', 'how\\'s', 'i', 'i\\'d', 'i\\'ll', 'i\\'m', 'i\\'ve', 'if', 'in', 'into', 'is', 'isn\\'t', 'it', 'it\\'s', 'its',\n      'itself', 'let\\'s', 'me', 'more', 'most', 'mustn\\'t', 'my', 'myself', 'no', 'nor', 'not', 'of', 'off', 'on', 'once',\n      'only', 'or', 'other', 'ought', 'our', 'ours', 'ourselves', 'out', 'over', 'own', 'same', 'shan\\'t', 'she', 'she\\'d',\n      'she\\'ll', 'she\\'s', 'should', 'shouldn\\'t', 'so', 'some', 'such', 'than', 'that', 'that\\'s', 'the', 'their', 'theirs',\n      'them', 'themselves', 'then', 'there', 'there\\'s', 'these', 'they', 'they\\'d', 'they\\'ll', 'they\\'re', 'they\\'ve', 'this',\n      'those', 'through', 'to', 'too', 'under', 'until', 'up', 'very', 'was', 'wasn\\'t', 'we', 'we\\'d', 'we\\'ll', 'we\\'re',\n      'we\\'ve', 'were', 'weren\\'t', 'what', 'what\\'s', 'when', 'when\\'s', 'where', 'where\\'s', 'which', 'while', 'who', 'who\\'s',\n      'whom', 'why', 'why\\'s', 'won\\'t', 'would', 'wouldn\\'t', 'you', 'you\\'d', 'you\\'ll', 'you\\'re', 'you\\'ve', 'your', 'yours',\n      'yourself', 'yourselves'\n    ];\n    \n    return frequencyData.filter(item => {\n      const word = item.word.toLowerCase();\n      return !stopWords.includes(word);\n    });\n  }\n  \n  /**\n   * Çoğul eklerini kaldır\n   */\n  static removeSuffixes(frequencyData: { word: string; frequency: number; category?: string }[]): { word: string; frequency: number; category?: string }[] {\n    return frequencyData.map(item => {\n      let word = item.word.toLowerCase();\n      \n      // Basit çoğul ek kaldırma kuralları\n      if (word.endsWith('ies')) {\n        word = word.slice(0, -3) + 'y';\n      } else if (word.endsWith('es')) {\n        word = word.slice(0, -2);\n      } else if (word.endsWith('s')) {\n        word = word.slice(0, -1);\n      }\n      \n      return {\n        ...item,\n        word,\n      };\n    });\n  }\n  \n  /**\n   * CSV dosyasını parse et\n   */\n  private static async parseCsvFile(file: File): Promise<any[]> {\n    return new Promise((resolve, reject) => {\n      Papa.parse(file, {\n        header: true,\n        skipEmptyLines: true,\n        complete: (results) => {\n          if (results.errors.length > 0) {\n            reject(new Error(`CSV parsing errors: ${results.errors.map(e => e.message).join(', ')}`));\n          } else {\n            resolve(results.data);\n          }\n        },\n        error: (error) => {\n          reject(error);\n        },\n      });\n    });\n  }\n  \n  /**\n   * Herhangi bir değeri güvenli şekilde number'a çevir\n   */\n  private static convertToNumber(value: any): number {\n    if (value === null || value === undefined || value === '') {\n      return 0;\n    }\n    \n    try {\n      // String ise temizle\n      if (typeof value === 'string') {\n        const cleaned = value.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n        if (cleaned === '' || cleaned === '-') {\n          return 0;\n        }\n        const parsed = parseFloat(cleaned);\n        return isNaN(parsed) ? 0 : parsed;\n      }\n      \n      // Number ise direkt döndür\n      if (typeof value === 'number') {\n        return isNaN(value) ? 0 : value;\n      }\n      \n      // Diğer tipler için string'e çevir ve parse et\n      const stringValue = String(value);\n      const cleaned = stringValue.replace(/,/g, '').replace(/%/g, '').replace(/\\s/g, '').trim();\n      const parsed = parseFloat(cleaned);\n      return isNaN(parsed) ? 0 : parsed;\n    } catch {\n      return 0;\n    }\n  }\n  \n  /**\n   * Growth değerini integer'a çevir (geriye uyumluluk için)\n   */\n  private static convertGrowthToInt(growth: any): number {\n    return this.convertToNumber(growth);\n  }\n  \n  /**\n   * Dosya adından kategori çıkar\n   */\n  private static extractCategoryFromFileName(fileName: string): string {\n    const nameWithoutExt = fileName.replace('.csv', '');\n    const parts = nameWithoutExt.split('-');\n    \n    if (parts.length >= 4 && parts[0] === 'trending' && parts[1] === 'keywords') {\n      return parts.slice(3).join('-');\n    } else {\n      return parts[parts.length - 1] || nameWithoutExt;\n    }\n  }\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}