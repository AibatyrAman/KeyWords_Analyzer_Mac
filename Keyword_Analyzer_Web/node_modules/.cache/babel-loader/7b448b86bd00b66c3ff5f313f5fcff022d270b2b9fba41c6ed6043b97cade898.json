{"ast":null,"code":"// OpenAI API configuration\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || \"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\";\nexport class SimilarKeywordFinder {\n  /**\n   * GPT API kullanarak benzer keyword'leri bul\n   */\n  static async findSimilarKeywords(searchTerm, availableKeywords, maxResults = 1000) {\n    try {\n      const systemPrompt = `\nYou are an expert in keyword analysis, semantic similarity, and typo detection. Your task is to analyze a search term and find similar keywords from a provided list.\n\nYour analysis should include:\n1. **Semantic Similarity**: Keywords with similar meaning or concept\n2. **Typo Detection**: Keywords that might be typos or misspellings of the search term\n3. **Variations**: Different forms, abbreviations, or alternative spellings\n4. **Related Concepts**: Keywords that are contextually related\n5. **Partial Matches**: Keywords that contain parts of the search term\n\nAnalysis Rules:\n- Focus on finding ALL possible matches within the provided keyword list\n- Consider typos, misspellings, and common variations\n- Look for semantic similarities and related concepts\n- Return only keywords that exist in the provided list\n- Return maximum ${maxResults} keywords\n- Return results as a JSON array of strings\n\nExamples:\nSearch term: \"weather\"\nPossible matches: \"weather\", \"weater\", \"wether\", \"weather app\", \"weather forecast\", \"climate\", \"temperature\"\n\nSearch term: \"photo\"\nPossible matches: \"photo\", \"foto\", \"photography\", \"photo editor\", \"photo filter\", \"image\", \"picture\"\n`;\n      const userPrompt = `\nSearch term: \"${searchTerm}\"\n\nAvailable keywords to search within:\n${availableKeywords.join(', ')}\n\nPlease analyze the search term and find ALL similar keywords from the above list, including:\n- Exact matches\n- Typos and misspellings\n- Semantic similarities\n- Related concepts\n- Partial matches\n\nReturn the most relevant keywords as a JSON array, ordered by relevance:\n`;\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${OPENAI_API_KEY}`\n        },\n        body: JSON.stringify({\n          model: 'gpt-4o-mini',\n          messages: [{\n            role: 'system',\n            content: systemPrompt\n          }, {\n            role: 'user',\n            content: userPrompt\n          }],\n          temperature: 0.2,\n          max_tokens: 1000\n        })\n      });\n\n      // Check if response is successful\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('OpenAI API error:', response.status, errorText);\n        throw new Error(`OpenAI API hatası: ${response.status}. Lütfen tekrar deneyin.`);\n      }\n      const result = await response.json();\n\n      // Check if response is valid\n      if (!result.choices || !result.choices[0] || !result.choices[0].message || !result.choices[0].message.content) {\n        console.error('Invalid OpenAI response:', result);\n        throw new Error('OpenAI API yanıtı geçersiz. Lütfen tekrar deneyin.');\n      }\n      const answer = result.choices[0].message.content.trim();\n      let similarKeywords = [];\n      try {\n        // Extract JSON from response\n        const jsonMatch = answer.match(/\\[.*\\]/);\n        if (jsonMatch) {\n          similarKeywords = JSON.parse(jsonMatch[0]);\n        } else {\n          // Fallback: try to parse the entire response\n          similarKeywords = JSON.parse(answer);\n        }\n\n        // Validate that all returned keywords exist in the original list\n        similarKeywords = similarKeywords.filter(keyword => availableKeywords.includes(keyword));\n\n        // Limit to maxResults\n        similarKeywords = similarKeywords.slice(0, maxResults);\n      } catch (parseError) {\n        console.error('Error parsing similar keywords response:', parseError);\n        // Fallback: use enhanced string matching\n        similarKeywords = this.enhancedFallbackSimilarKeywords(searchTerm, availableKeywords, maxResults);\n      }\n      return similarKeywords;\n    } catch (error) {\n      console.error('Error finding similar keywords:', error);\n      // Fallback to enhanced matching if API fails\n      return this.enhancedFallbackSimilarKeywords(searchTerm, availableKeywords, maxResults);\n    }\n  }\n\n  /**\n   * Enhanced fallback method for finding similar keywords with typo detection\n   */\n  static enhancedFallbackSimilarKeywords(searchTerm, availableKeywords, maxResults) {\n    const searchWords = searchTerm.toLowerCase().split(/\\s+/);\n    const scoredKeywords = availableKeywords.map(keyword => {\n      const keywordWords = keyword.toLowerCase().split(/\\s+/);\n      let score = 0;\n\n      // Exact match gets highest score\n      if (keyword.toLowerCase().includes(searchTerm.toLowerCase())) {\n        score += 15;\n      }\n\n      // Exact word match\n      if (keyword.toLowerCase() === searchTerm.toLowerCase()) {\n        score += 20;\n      }\n\n      // Word overlap scoring\n      searchWords.forEach(searchWord => {\n        keywordWords.forEach(keywordWord => {\n          if (keywordWord.includes(searchWord) || searchWord.includes(keywordWord)) {\n            score += 3;\n          }\n          if (keywordWord === searchWord) {\n            score += 8;\n          }\n\n          // Typo detection using Levenshtein distance\n          const similarity = this.calculateStringSimilarity(searchWord, keywordWord);\n          if (similarity > 0.8) {\n            score += 5;\n          } else if (similarity > 0.6) {\n            score += 2;\n          }\n        });\n      });\n\n      // Partial match scoring\n      if (keyword.toLowerCase().includes(searchTerm.toLowerCase().slice(0, 3))) {\n        score += 1;\n      }\n      return {\n        keyword,\n        score\n      };\n    });\n    return scoredKeywords.filter(item => item.score > 0).sort((a, b) => b.score - a.score).slice(0, maxResults).map(item => item.keyword);\n  }\n\n  /**\n   * Calculate string similarity using Levenshtein distance\n   */\n  static calculateStringSimilarity(str1, str2) {\n    if (str1 === str2) return 1;\n    if (str1.length === 0 || str2.length === 0) return 0;\n    const longer = str1.length > str2.length ? str1 : str2;\n    const shorter = str1.length > str2.length ? str2 : str1;\n    if (longer.length === 0) return 1;\n    return (longer.length - this.levenshteinDistance(longer, shorter)) / longer.length;\n  }\n\n  /**\n   * Calculate Levenshtein distance between two strings\n   */\n  static levenshteinDistance(str1, str2) {\n    const matrix = [];\n    for (let i = 0; i <= str2.length; i++) {\n      matrix[i] = [i];\n    }\n    for (let j = 0; j <= str1.length; j++) {\n      matrix[0][j] = j;\n    }\n    for (let i = 1; i <= str2.length; i++) {\n      for (let j = 1; j <= str1.length; j++) {\n        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1];\n        } else {\n          matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);\n        }\n      }\n    }\n    return matrix[str2.length][str1.length];\n  }\n\n  /**\n   * Fallback method for finding similar keywords using simple string matching\n   */\n  static fallbackSimilarKeywords(searchTerm, availableKeywords, maxResults) {\n    const searchWords = searchTerm.toLowerCase().split(/\\s+/);\n    const scoredKeywords = availableKeywords.map(keyword => {\n      const keywordWords = keyword.toLowerCase().split(/\\s+/);\n      let score = 0;\n\n      // Exact match gets highest score\n      if (keyword.toLowerCase().includes(searchTerm.toLowerCase())) {\n        score += 10;\n      }\n\n      // Word overlap scoring\n      searchWords.forEach(searchWord => {\n        keywordWords.forEach(keywordWord => {\n          if (keywordWord.includes(searchWord) || searchWord.includes(keywordWord)) {\n            score += 2;\n          }\n          if (keywordWord === searchWord) {\n            score += 5;\n          }\n        });\n      });\n      return {\n        keyword,\n        score\n      };\n    });\n    return scoredKeywords.filter(item => item.score > 0).sort((a, b) => b.score - a.score).slice(0, maxResults).map(item => item.keyword);\n  }\n\n  /**\n   * Mevcut keyword'lerden benzer olanları filtrele\n   */\n  static filterBySimilarKeywords(data, similarKeywords) {\n    if (similarKeywords.length === 0) return data;\n    return data.filter(item => {\n      const keyword = String(item.Keyword || '').toLowerCase();\n      return similarKeywords.some(similarKeyword => keyword.includes(similarKeyword.toLowerCase()) || similarKeyword.toLowerCase().includes(keyword));\n    });\n  }\n}","map":{"version":3,"names":["OPENAI_API_KEY","process","env","REACT_APP_OPENAI_API_KEY","SimilarKeywordFinder","findSimilarKeywords","searchTerm","availableKeywords","maxResults","systemPrompt","userPrompt","join","response","fetch","method","headers","body","JSON","stringify","model","messages","role","content","temperature","max_tokens","ok","errorText","text","console","error","status","Error","result","json","choices","message","answer","trim","similarKeywords","jsonMatch","match","parse","filter","keyword","includes","slice","parseError","enhancedFallbackSimilarKeywords","searchWords","toLowerCase","split","scoredKeywords","map","keywordWords","score","forEach","searchWord","keywordWord","similarity","calculateStringSimilarity","item","sort","a","b","str1","str2","length","longer","shorter","levenshteinDistance","matrix","i","j","charAt","Math","min","fallbackSimilarKeywords","filterBySimilarKeywords","data","String","Keyword","some","similarKeyword"],"sources":["/Users/aibatyr/Documents/GitHub/KeyWords_Analyzer_Web/Keyword_Analyzer_Web/src/utils/similarKeywordFinder.ts"],"sourcesContent":["import { KeywordData } from '../types';\n\n// OpenAI API configuration\nconst OPENAI_API_KEY = process.env.REACT_APP_OPENAI_API_KEY || \"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\";\n\nexport class SimilarKeywordFinder {\n  \n  /**\n   * GPT API kullanarak benzer keyword'leri bul\n   */\n  static async findSimilarKeywords(\n    searchTerm: string, \n    availableKeywords: string[], \n    maxResults: number = 1000\n  ): Promise<string[]> {\n    try {\n      const systemPrompt = `\nYou are an expert in keyword analysis, semantic similarity, and typo detection. Your task is to analyze a search term and find similar keywords from a provided list.\n\nYour analysis should include:\n1. **Semantic Similarity**: Keywords with similar meaning or concept\n2. **Typo Detection**: Keywords that might be typos or misspellings of the search term\n3. **Variations**: Different forms, abbreviations, or alternative spellings\n4. **Related Concepts**: Keywords that are contextually related\n5. **Partial Matches**: Keywords that contain parts of the search term\n\nAnalysis Rules:\n- Focus on finding ALL possible matches within the provided keyword list\n- Consider typos, misspellings, and common variations\n- Look for semantic similarities and related concepts\n- Return only keywords that exist in the provided list\n- Return maximum ${maxResults} keywords\n- Return results as a JSON array of strings\n\nExamples:\nSearch term: \"weather\"\nPossible matches: \"weather\", \"weater\", \"wether\", \"weather app\", \"weather forecast\", \"climate\", \"temperature\"\n\nSearch term: \"photo\"\nPossible matches: \"photo\", \"foto\", \"photography\", \"photo editor\", \"photo filter\", \"image\", \"picture\"\n`;\n\n      const userPrompt = `\nSearch term: \"${searchTerm}\"\n\nAvailable keywords to search within:\n${availableKeywords.join(', ')}\n\nPlease analyze the search term and find ALL similar keywords from the above list, including:\n- Exact matches\n- Typos and misspellings\n- Semantic similarities\n- Related concepts\n- Partial matches\n\nReturn the most relevant keywords as a JSON array, ordered by relevance:\n`;\n\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${OPENAI_API_KEY}`\n        },\n        body: JSON.stringify({\n          model: 'gpt-4o-mini',\n          messages: [\n            { role: 'system', content: systemPrompt },\n            { role: 'user', content: userPrompt }\n          ],\n          temperature: 0.2,\n          max_tokens: 1000\n        })\n      });\n\n      // Check if response is successful\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('OpenAI API error:', response.status, errorText);\n        throw new Error(`OpenAI API hatası: ${response.status}. Lütfen tekrar deneyin.`);\n      }\n\n      const result = await response.json();\n      \n      // Check if response is valid\n      if (!result.choices || !result.choices[0] || !result.choices[0].message || !result.choices[0].message.content) {\n        console.error('Invalid OpenAI response:', result);\n        throw new Error('OpenAI API yanıtı geçersiz. Lütfen tekrar deneyin.');\n      }\n      \n      const answer = result.choices[0].message.content.trim();\n      \n      let similarKeywords: string[] = [];\n      try {\n        // Extract JSON from response\n        const jsonMatch = answer.match(/\\[.*\\]/);\n        if (jsonMatch) {\n          similarKeywords = JSON.parse(jsonMatch[0]);\n        } else {\n          // Fallback: try to parse the entire response\n          similarKeywords = JSON.parse(answer);\n        }\n        \n        // Validate that all returned keywords exist in the original list\n        similarKeywords = similarKeywords.filter(keyword => \n          availableKeywords.includes(keyword)\n        );\n        \n        // Limit to maxResults\n        similarKeywords = similarKeywords.slice(0, maxResults);\n        \n      } catch (parseError) {\n        console.error('Error parsing similar keywords response:', parseError);\n        // Fallback: use enhanced string matching\n        similarKeywords = this.enhancedFallbackSimilarKeywords(searchTerm, availableKeywords, maxResults);\n      }\n\n      return similarKeywords;\n\n    } catch (error) {\n      console.error('Error finding similar keywords:', error);\n      // Fallback to enhanced matching if API fails\n      return this.enhancedFallbackSimilarKeywords(searchTerm, availableKeywords, maxResults);\n    }\n  }\n\n  /**\n   * Enhanced fallback method for finding similar keywords with typo detection\n   */\n  private static enhancedFallbackSimilarKeywords(\n    searchTerm: string, \n    availableKeywords: string[], \n    maxResults: number\n  ): string[] {\n    const searchWords = searchTerm.toLowerCase().split(/\\s+/);\n    \n    const scoredKeywords = availableKeywords.map(keyword => {\n      const keywordWords = keyword.toLowerCase().split(/\\s+/);\n      let score = 0;\n      \n      // Exact match gets highest score\n      if (keyword.toLowerCase().includes(searchTerm.toLowerCase())) {\n        score += 15;\n      }\n      \n      // Exact word match\n      if (keyword.toLowerCase() === searchTerm.toLowerCase()) {\n        score += 20;\n      }\n      \n      // Word overlap scoring\n      searchWords.forEach(searchWord => {\n        keywordWords.forEach(keywordWord => {\n          if (keywordWord.includes(searchWord) || searchWord.includes(keywordWord)) {\n            score += 3;\n          }\n          if (keywordWord === searchWord) {\n            score += 8;\n          }\n          \n          // Typo detection using Levenshtein distance\n          const similarity = this.calculateStringSimilarity(searchWord, keywordWord);\n          if (similarity > 0.8) {\n            score += 5;\n          } else if (similarity > 0.6) {\n            score += 2;\n          }\n        });\n      });\n      \n      // Partial match scoring\n      if (keyword.toLowerCase().includes(searchTerm.toLowerCase().slice(0, 3))) {\n        score += 1;\n      }\n      \n      return { keyword, score };\n    });\n    \n    return scoredKeywords\n      .filter(item => item.score > 0)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, maxResults)\n      .map(item => item.keyword);\n  }\n\n  /**\n   * Calculate string similarity using Levenshtein distance\n   */\n  private static calculateStringSimilarity(str1: string, str2: string): number {\n    if (str1 === str2) return 1;\n    if (str1.length === 0 || str2.length === 0) return 0;\n    \n    const longer = str1.length > str2.length ? str1 : str2;\n    const shorter = str1.length > str2.length ? str2 : str1;\n    \n    if (longer.length === 0) return 1;\n    \n    return (longer.length - this.levenshteinDistance(longer, shorter)) / longer.length;\n  }\n\n  /**\n   * Calculate Levenshtein distance between two strings\n   */\n  private static levenshteinDistance(str1: string, str2: string): number {\n    const matrix = [];\n    \n    for (let i = 0; i <= str2.length; i++) {\n      matrix[i] = [i];\n    }\n    \n    for (let j = 0; j <= str1.length; j++) {\n      matrix[0][j] = j;\n    }\n    \n    for (let i = 1; i <= str2.length; i++) {\n      for (let j = 1; j <= str1.length; j++) {\n        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1];\n        } else {\n          matrix[i][j] = Math.min(\n            matrix[i - 1][j - 1] + 1,\n            matrix[i][j - 1] + 1,\n            matrix[i - 1][j] + 1\n          );\n        }\n      }\n    }\n    \n    return matrix[str2.length][str1.length];\n  }\n\n  /**\n   * Fallback method for finding similar keywords using simple string matching\n   */\n  private static fallbackSimilarKeywords(\n    searchTerm: string, \n    availableKeywords: string[], \n    maxResults: number\n  ): string[] {\n    const searchWords = searchTerm.toLowerCase().split(/\\s+/);\n    \n    const scoredKeywords = availableKeywords.map(keyword => {\n      const keywordWords = keyword.toLowerCase().split(/\\s+/);\n      let score = 0;\n      \n      // Exact match gets highest score\n      if (keyword.toLowerCase().includes(searchTerm.toLowerCase())) {\n        score += 10;\n      }\n      \n      // Word overlap scoring\n      searchWords.forEach(searchWord => {\n        keywordWords.forEach(keywordWord => {\n          if (keywordWord.includes(searchWord) || searchWord.includes(keywordWord)) {\n            score += 2;\n          }\n          if (keywordWord === searchWord) {\n            score += 5;\n          }\n        });\n      });\n      \n      return { keyword, score };\n    });\n    \n    return scoredKeywords\n      .filter(item => item.score > 0)\n      .sort((a, b) => b.score - a.score)\n      .slice(0, maxResults)\n      .map(item => item.keyword);\n  }\n\n  /**\n   * Mevcut keyword'lerden benzer olanları filtrele\n   */\n  static filterBySimilarKeywords(\n    data: KeywordData[], \n    similarKeywords: string[]\n  ): KeywordData[] {\n    if (similarKeywords.length === 0) return data;\n    \n    return data.filter(item => {\n      const keyword = String(item.Keyword || '').toLowerCase();\n      return similarKeywords.some(similarKeyword => \n        keyword.includes(similarKeyword.toLowerCase()) ||\n        similarKeyword.toLowerCase().includes(keyword)\n      );\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}